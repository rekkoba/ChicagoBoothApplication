# -*- coding: utf-8 -*-
"""231226_Chicago_v2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JRzOG-bySU7h_dSAhtj31zdOw0dkcKTF
"""

# This is a part of the code I worked on in a six-month AI learning program sponsored by the Ministry of Economics in Japan.
# The PDF is just the beginning of the project, and more analysis and functions are included in the latter. The whole code can be found in the URL below.
# https://github.com/rekkoba/ChicagoBoothApplication

import pandas as pd
import numpy as np
import os
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from xgboost import XGBClassifier
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import mean_squared_error as MSE

from google.colab import drive
drive.mount('/content/drive')

os.chdir('/content/drive/MyDrive/Python')

train = pd.read_csv("train.csv", sep=",")
test = pd.read_csv("test.csv", sep=",")
submission = pd.read_csv("sample_submit.csv", sep=",", index_col=0, header=None)

# train.isnull().sum()

# Remove data only from the train set in case of missing or outlier values
train = train.dropna(subset=['bathrooms', 'bedrooms', 'beds'])

train.describe()

mean_val = train['review_scores_rating'].mean()
train['review_scores_rating'] = train['review_scores_rating'].fillna(mean_val)
test['review_scores_rating'] = test['review_scores_rating'].fillna(mean_val)

y = train['y']
y.plot.hist(title='Accomodation Price')
plt.show()

print(y.value_counts().sort_index())

before_rows = train.shape[0]
print(before_rows)

train = train[train['y'] >= 10]

after_rows = train.shape[0]
print(after_rows)

counts = train['room_type'].value_counts()
counts.plot.bar(title='Frequency of room_type')
plt.xlabel('room_type')
plt.ylabel('count')
plt.show()

sns.boxplot(data=train, x='accommodates', y='y')
plt.show()

train.corr()

sns.boxplot(data=train, x='room_type', y='y')
plt.ylim(0,600)
plt.show()

train.plot.scatter(x='review_scores_rating', y='y')
plt.show()

train.plot.scatter(x='number_of_reviews', y='y')
plt.show()

sns.boxplot(data=train, x='bed_type', y='y')
plt.ylim(0,1000)
plt.show()

sns.boxplot(data=train, x='bathrooms', y='y')
plt.show()

train_tmp = train[(train['bathrooms']==0)&(train['y']>=1000)]
print(train_tmp)
print(train_tmp['name'])

def change_tf(x):
  if x == 't':
    return 1
  elif x == 'f':
    return 0

train['cleaning_fee'] = train['cleaning_fee'].apply(change_tf)
train['host_has_profile_pic'] = train['host_has_profile_pic'].apply(change_tf)
train['host_identity_verified'] = train['host_identity_verified'].apply(change_tf)
train['instant_bookable'] = train['instant_bookable'].apply(change_tf)

test['cleaning_fee'] = test['cleaning_fee'].apply(change_tf)
test['host_has_profile_pic'] = test['host_has_profile_pic'].apply(change_tf)
test['host_identity_verified'] = test['host_identity_verified'].apply(change_tf)
test['instant_bookable'] = test['instant_bookable'].apply(change_tf)

sns.boxplot(data=train, x='cleaning_fee', y='y')
plt.ylim(0,600)
plt.show()

sns.boxplot(data=train, x='host_identity_verified', y='y')
plt.ylim(0,600)
plt.show()

sns.boxplot(data=train, x='instant_bookable', y='y')
plt.ylim(0,600)
plt.show()

sns.boxplot(data=train[train['room_type'] == 'Entire home/apt'], x='bathrooms', y='y')

sns.boxplot(data=train[train['room_type'] == 'Shared room'], x='bathrooms', y='y')

sns.boxplot(data=train, x='beds', y='y')

train.corr()

train.isnull().sum()

train.info()

train.head()

# Try the model better once again
train.amenities = train.amenities.str.count(',') +1
test.amenities = test.amenities.str.count(',') +1

train['super_strict_60'] = 0
train.loc[train['cancellation_policy'] == 'super_strict_60', 'super_strict_60'] = 1
test['super_strict_60'] = 0
test.loc[test['cancellation_policy'] == 'super_strict_60', 'super_strict_60'] = 1

train['description'] = train['description'].apply(lambda x: len(x))
test['description'] = test['description'].apply(lambda x: len(x))

train['real_bed'] = 0
train.loc[train['bed_type'] == 'Real Bed', 'real_bed'] = 1
test['real_bed'] = 0
test.loc[test['bed_type'] == 'Real Bed', 'read_bed'] = 1

sns.boxplot(data=train, x='real_bed', y='y')

train['thumbnail_url'].fillna(0, inplace=True)
test['thumbnail_url'].fillna(0, inplace=True)

train['thumbnail'] = 0
train.loc[train['thumbnail_url'] != 0, 'thumbnail'] = 1
test['thumbnail'] = 0
test.loc[test['thumbnail_url'] != 0, 'thumbnail'] = 1

train['thumbnail'].value_counts()

train.head()

train.corr()

select_columns = ['room_type', 'accommodates', 'bed_type', 'bathrooms', 'cleaning_fee', 'beds', 'latitude', 'longitude', 'number_of_reviews', 'review_scores_rating', 'amenities', 'instant_bookable', 'description', 'real_bed', 'thumbnail']

train_entire = train[train['room_type'] == 'Entire home/apt']
train_private = train[train['room_type'] == 'Private room']
train_share = train[train['room_type'] == 'Shared room']
dummy_train_entire = pd.get_dummies(train_entire[select_columns], drop_first=True)
dummy_train_private = pd.get_dummies(train_private[select_columns], drop_first=True)
dummy_train_share = pd.get_dummies(train_share[select_columns], drop_first=True)

# Data splitting
X_train_e, X_validation_e, y_train_e, y_validation_e = train_test_split(dummy_train_entire, train_entire['y'], random_state = 1234)
X_train_p, X_validation_p, y_train_p, y_validation_p = train_test_split(dummy_train_private, train_private['y'], random_state = 1234)
X_train_s, X_validation_s, y_train_s, y_validation_s = train_test_split(dummy_train_share, train_share['y'], random_state = 1234)

# entire
# Model preparation
model_e = RandomForestRegressor(random_state=0, max_depth=30)
# Model training
model_e.fit(X_train_e, y_train_e)
# Predicting the training data
pred_e_train = model_e.predict(X_train_e)
# Predicting the test data
pred_e_validation = model_e.predict(X_validation_e)

# private
# Model preparation
model_p = RandomForestRegressor(random_state=0, max_depth=30)
# Model training
model_p.fit(X_train_p, y_train_p)
# Predicting the training data
pred_p_train = model_p.predict(X_train_p)
# Predicting the test data
pred_p_validation = model_p.predict(X_validation_p)

# share
# Model preparation
model_s = RandomForestRegressor(random_state=0, max_depth=30)
# Model training
model_s.fit(X_train_s, y_train_s)
# Predicting the training data
pred_s_train = model_s.predict(X_train_s)
# Predicting the test data
pred_s_validation = model_s.predict(X_validation_s)

import numpy as np
from sklearn.metrics import mean_squared_error as MSE

# Combining pred_e_train, pred_p_train, pred_s_train into one array and assign it to pred_train
pred_train = np.concatenate([pred_e_train, pred_p_train, pred_s_train])
# Combine the actual values y_train_e, y_train_p, y_train_s into one array and assign it to answer_train.
answer_train = np.concatenate([y_train_e, y_train_p, y_train_s])
# Calculate the RMSE of all training data predictions and assign it to rmse_train from pred_train, answer_train
rmse_train = np.sqrt(MSE(answer_train, pred_train))

# Similarly, calculating the RMSE of all test data predictions and assign it to rmse_validation
pred_validation = np.concatenate([pred_e_validation, pred_p_validation, pred_s_validation])
answer_validation = np.concatenate([y_validation_e, y_validation_p, y_validation_s])
rmse_validation = np.sqrt(MSE(answer_validation, pred_validation))

print(rmse_train)
print(rmse_validation)

# Conduct predictions on the test data

test.info()

plt.hist(test['beds'])

# Fill the 12 missing values out of 10,371 in bathrooms with the average
test_bathrooms_mean = test['bathrooms'].mean()
test['bathrooms'] = test['bathrooms'].fillna(test_bathrooms_mean)

# There were missing values in the added 'beds'
test['beds'] = test['beds'].fillna(test_bathrooms_mean)

test_entire = test[test['room_type'] == 'Entire home/apt']
test_private = test[test['room_type'] == 'Private room']
test_share = test[test['room_type'] == 'Shared room']
dummy_test_entire = pd.get_dummies(test_entire[select_columns], drop_first=True)
dummy_test_private = pd.get_dummies(test_private[select_columns], drop_first=True)
dummy_test_share = pd.get_dummies(test_share[select_columns], drop_first=True)

# entire
pred_e_test = model_e.predict(dummy_test_entire)
# private
pred_p_test = model_p.predict(dummy_test_private)
# share
pred_s_test = model_s.predict(dummy_test_share)

test_re_merge = pd.concat([test_entire, test_private, test_share])
pred_test = np.concatenate([pred_e_test, pred_p_test, pred_s_test])

plt.hist(dummy_test_entire['bathrooms'])

test_re_merge['pred_y'] = pred_test

pred_test_sorted = test_re_merge.sort_values('id')
pred_test_sorted

submission[1] = pred_test_sorted['pred_y']
submission

submission.to_csv('submit.csv', header=None)

